---
layout: post
title: "Data Modeling"
author: Zach Bernheimer
---
## Reflection:
The prompt for this lab was to create an entity relationship diagram and database schema based on the following scenario:

>Your local grocery store would like your help in creating an online grocery shopping web application. The owner of the store will be able to list items for sale, where the items have a name, price, description, quantity available, and a manufacturer. Customers will be able to go to the site and register to create an account, entering in their name, address, and phone number. Once registered, customers will be able to start an order for pickup or delivery. The customer can select from the food items the store has for sale. When an item is selected, the customer will note the quantity desired, any special instructions, and if this item can be substituted if the store is out of stock. Finally, when the customer finalizes their order, they will be able to choose a time and date for their order to be fulfilled. Finalized orders can no longer be changed by the customer.

### Entity Relationship Diagram
From this prompt, I identified three entities: Item, Customer, and Order. I decided to make orders a separate entity rather than an interaction because they store their own information and most importantly they exist even after the customer stops interacting with them (i.e. after they have been finalized.) Another choice I made was to give each customer an attribute that was not listed in the prompt: A unique ID. While name, address, and phone number could in most cases identify an individual customer, it's possible that two customers with the same name might live at the same address. For example, a parent named Bob Random might have a kid named Bob Random Jr, who didn't include the Jr when registering for an account. If both Bob Randoms live in the same house, they might well have a landline phone that they both used to create their grocery store accounts, in which case we would have no way of distinguishing between the two. Assigning each customer a unique ID upon registration is a simple way to keep track of individual customers without having to rely on their personal information being unique. For similar reasons, I also added an ID attribute to the Order entity, so that we have a way to uniquely identify a single order, even before it is finalized. This way, a customer can create multiple orders at the same time, or create multiple separate orders to be picked up or delivered together.

I used these entities and the properties of Items and Customers listed in the prompt to create an Entity Relationship Diagram with LucidChart, which is shown below.
![Grocery Store Entity Relationship Diagram]({{"/assets/images/posts/2023-10-15/Store_ERD.png" | relative_url}})

The cardinality of these relationships was also something I considered when creating this diagram. Walking through the process of ordering groceries, a customer can create any number of orders, but each order can only have exactly one customer. Meanwhile, an order must have at least one item, and a particular item can be a part of any number of orders. The important factor here is that none of the items are treated as unique, so there is no theoretical limit on how many can be ordered or how many people can order one item. While of course we only have a certain quantity of each item in stock, this limitation is not part of the data model, since we can presumably order more when we run out. 

### Database Schema
Finally, I used Vertabelo to create a SQLite database schema for this scenario, pictured below:
![Grocery Store Database Schema]({{"/assets/images/posts/2023-10-15/Store_schema.png" | relative_url}})

The customer, item, and order tables were essentially just translations from my entity relationship diagram, with columns that match the attributes I defined in that diagram. However, I added two new tables to the schema that don't directly follow from the ERD, which are "item_order" and "manufacturer". Manufacturer is simply a table to keep track of each manufacturer, so that the id of the manufacturer can be referenced by items. Since manufacturer id is a foreign key in the item table, this will allow a database query to find all items by a specific manufacturer or to look up the manufacturer information of a specific item. Separating this into its own table will also allow multiple manufacturers with the same name to be given unique id and kept separate in the database.

The other new table "item_order" is more complex. I needed this table to store item-specific information from the entity relationship diagram, such as specific instructions for each item and the quantity requested. However, this information cannot be part of the item table since the information is only relavent to the specific order, and it can't be part of the order because each order can have multiple items, each with their own special instructions. The solution I came up with was to create a table that uses the foreign keys "order_id" and "item_id" as a compound primary key. This means that an entry in this table is uniquely identified by the order and item, so we can have multiple entries for the same order with different items, or multiple orders for the same item, but never multiples of the same item in a single order. This makes sense, because if a customer is ordering an item, they should use the quantity field to order more than one, rather than requesting only one of that item multiple times. The cardinality of this table's connections was tricky for me to determine, but I think I ended up with a good representation of how the data should function. Each order can have 1 or more item_orders attached to it, while each item_order must have exactly one order. Meanwhile, each item order can only (and must) have one item, while a given item can be a part of any number of item orders.

### Implementation Challenges
All these connections and tables work together to create a database that can facilitate the scenarios described in the prompt. Even so, there are still a few potential implementation challenges with this model. For example, every time a customer finalizes an order for an item, the implementation needs to check if enough of the requested item is in stock. If it is, the order can be finalized and the in-stock item quantity reduced by the number ordered. If not, things get more complicated. 

If the user did not say that substitutions are acceptable, then we have several options for how to handle it. We could make it so that an order cannot be finalized if the quantity of a given item requested is greater than the number in stock and no substitutions are allowed. This is simple, but we risk the customer ordering the items from someone else. Another option is to backorder the item and add a wait time to the customer's order. Potentially, we could offer the customer to split the order into two, so the items that can be fulfilled immediately are, rather than having to wait for the entire order to be in stock.

Substitutions are another issue in and of themselves. The database currently does not store any information about item categories, or any other data we could use to determine if a given item is an acceptable substitute for another. While this could just be done manually if the scale is small enough, modifications to the database could allow this to happen automatically. For example, we could label an item as part of the broader category "toilet paper" and if the specific brand requesed is out of stock, we could suggest a replacement item from that same category.

The most challenging aspect of all of this implementation is scale. If the store is only recieving a few dozen orders a day, or even every hour, they will almost certainly not happen at the same time. However, the greater the order volume, the more we risk running into conflicts, especially when we're trying to check or update the quantity of an item that is left in stock. With item replacements as well, a large volume of requests would mean that maually selecting an alternate item would be unfeasable, so we would have to make the modifications discussed above.

### Conclusion
All in all, I'm fairly satisfied with this data representation. Despite the potential pitfalls of implementing and scaling an application with this model, I think it provides everything that this local grocery store needs, while also allowing for future growth and automation if needed.